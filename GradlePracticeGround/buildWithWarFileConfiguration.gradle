plugins {
    id 'groovy'
    id 'java'
    id 'war'
    id 'org.gretty' version '2.2.0'
}

import com.gradle.*

group 'MyGradle'
version '1.0-SNAPSHOT'

setDescription("Gradle Practice ground")
println "Description of project $name:" + project.description

//Extra Properties (Could be injected via org.gt.gradle.properties as well)
project.ext.myProp = "myValue"
ext {
    someOtherProp = 123
}

assert myProp == "myValue"
println project.someOtherProp
ext.someOtherProp = 567

//Setting project version
project.version = "1.0-SNAPSHOT"

sourceCompatibility = 1.8

repositories {
    mavenCentral()
    maven {
        url "http://repo.spring.io/libs-release"
    }
}

jar {
    manifest {
        attributes "Main-Class" : "com.manning.gia.todo.ToDoApp"
    }
}

dependencies {
    compile group: 'org.projectlombok', name: 'lombok', version: '1.18.4'
    providedCompile 'javax.servlet:servlet-api:2.5'
    runtime 'javax.servlet:jstl:1.1.2'
    implementation gradleApi()
    implementation localGroovy()
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

//TaskActions
task first {
    doLast({ println "first" })
}
task second {
    doLast({ println "second" })
}

task printVersion(group: "versioning", description: "Prints project version", dependsOn: [second, first]) {
    doFirst {
        println "Before reading the project version"
    }
    .doLast {
        logger.quiet "Version: $version"
    }
}

task third(dependsOn: [printVersion]) {
    doLast({ println "third" })
}

//Adding Arbitrary code
version = new ProjectVersion(0, 1)

ext.versionFile = file('version.properties')

//Task Configuration (Defined without the left shift operators).
// These blocks are executed even before task action.
task loadVersion {
    project.version = readVersion()
}

ProjectVersion readVersion() { //Invoked in Configuration Phase
    logger.quiet("Reading the version file")

    if (!versionFile.exists()) {
        throw new GradleException("Required version file ($versionFile.canonicalPath) does not exist")
    }

    Properties versionProperties = new Properties()

    versionFile.withInputStream {
        stream -> versionProperties.load(stream)
    }

    new ProjectVersion(versionProperties.major.toInteger(),
            versionProperties.minor.toInteger(), versionProperties.release.toBoolean())
}


task makeReleaseVersion(type: ReleaseVersionTask) {
    release = version.release
    destFile = versionFile
}

task createDistribution(type: Zip, dependsOn: makeReleaseVersion) {
    from(sourceSets*.allSource) { //Takes all files and puts them into source Directory
        into 'src'
    }

    from(rootDir) {
        include versionFile.name //Adds version file to zip
    }
}

task backupReleaseDistribution(type: Copy) {
    //Not declaring dependency on the task createDistribution but just using the output of that.
    from createDistribution.outputs.files
    into "$buildDir/backup"
}

task release(dependsOn: backupReleaseDistribution) {
    doLast() {
        logger.quiet("Releasing the project")
    }
}

//Adding task rules
tasks.addRule("Pattern: increment<Classifier>Version - Increments the project version classifier.") {
    String taskName ->
        if (taskName.startsWith("increment") && taskName.endsWith("Version")) {
            task(taskName) {
                String classifer = (taskName - "increment" - "version").toLowerCase() //Extracting classifier
                String currentVersion = version.toString()

                switch (classifer) {
                    case "major": ++version.major
                        break
                    case "minor": ++version.minor
                        break
                    default: throw new GradleException("Invalid version type $classifier. Allowed Types: ['Major','Minor']")
                }

                String newVersion = version.toString()
                logger.info "Incrementing $classifer project version: $currentVersion -> $newVersion"
                ant.propertyFile(file: versionFile) {
                    entry(key: classifier, type: "int", operation: "+", value: 1)
                }
            }
        }
}
//Hooking into task execution graph
gradle.taskGraph.whenReady { TaskExecutionGraph taskExecutionGraph ->
    if (taskExecutionGraph.hasTask(release)) {
        if (!version.release) {
            version.release = true
            ant.propertyfile(file: versionFile) {
                entry(key: "release", type: "string", operation: "=", value: "true")
            }
        }
    }
}

def releaseVersionListener = new ReleaseVersionListener()
gradle.taskGraph.addTaskExecutionGraphListener(releaseVersionListener)